ğŸš€ Rate-Limited API Gateway (Spring Cloud Gateway + Redis)

A production-grade API Gateway built with Spring Cloud Gateway, demonstrating real-world gateway patterns used in modern microservice architectures.

This project focuses on security, resilience, and observability, not just routing.

ğŸ§± Architecture Overview
Client
  â”‚
  â”‚  HTTP requests
  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Gateway Service  â”‚
â”‚  (Spring Cloud Gateway)â”‚
â”‚                        â”‚
â”‚  â€¢ API Key Auth        â”‚
â”‚  â€¢ Rate Limiting       â”‚â”€â”€ Redis
â”‚  â€¢ Circuit Breaker     â”‚
â”‚  â€¢ Request Logging     â”‚
â”‚  â€¢ Correlation IDs     â”‚
â”‚  â€¢ OpenTelemetry       â”‚â”€â”€ Jaeger
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
     Demo Backend Service

ğŸ§© Services
1ï¸âƒ£ Gateway Service

Port: 8080

Acts as the single entry point to backend services.

2ï¸âƒ£ Demo Service

Port: 8081

A simple backend used to test routing, failures, and observability.

âœ… Features Implemented
ğŸ” API Key Authentication

Requests must include X-API-Key

Missing or invalid key â†’ 401 Unauthorized

Keys are configurable via application.yml

ğŸš¦ Distributed Rate Limiting (Redis)

Token Bucket algorithm

Backed by Redis (safe for multiple gateway instances)

Rate limits enforced:

Per API key (authenticated requests)

Fallback per IP (when API key logic is allowed)

Returns standard headers:

X-RateLimit-Remaining

X-RateLimit-Burst-Capacity

X-RateLimit-Replenish-Rate

ğŸ” Circuit Breaker + Fallback (Resilience4j)

Automatically opens when backend fails or times out

Prevents cascading failures

Returns a graceful fallback response:

{
  "status": 503,
  "error": "upstream_unavailable",
  "message": "Fallback response from gateway",
  "correlationId": "..."
}

ğŸ§  Correlation IDs (Tracing-Friendly)

Every request gets a X-Correlation-Id

Generated automatically if missing

Propagated:

Gateway logs

Downstream services

Fallback responses

Returned to the client for debugging

ğŸ§¾ Structured JSON Logging

Logs are emitted in JSON format

Ready for:

ELK

Loki

Datadog

Each log includes:

correlationId

HTTP status

latency (ms)

method & path

masked API key

Example:

{
  "message": "corrId=... status=429 ms=6 method=GET path=/api/hello",
  "app": "gateway-service"
}

ğŸ” Distributed Tracing (OpenTelemetry)

Uses Micrometer Tracing + OpenTelemetry

Exports traces to Jaeger

Visualizes:

Request latency

Errors

Circuit breaker behavior

Correlation ID aligns with trace ID for easy debugging

ğŸ›  Tech Stack

Java 17

Spring Boot 3

Spring Cloud Gateway

Redis

Resilience4j

Micrometer + OpenTelemetry

Jaeger

Logstash Logback Encoder

â–¶ï¸ How to Run
1ï¸âƒ£ Start Redis
docker run -d -p 6379:6379 redis

2ï¸âƒ£ Start Jaeger
docker run -d --name jaeger \
  -p 16686:16686 \
  -p 4318:4318 \
  jaegertracing/all-in-one:1.53


Jaeger UI: http://localhost:16686

3ï¸âƒ£ Run Demo Service
cd demo-service
mvn spring-boot:run

4ï¸âƒ£ Run Gateway Service
cd gateway-service
mvn spring-boot:run

ğŸ§ª Example Request
curl http://localhost:8080/api/hello \
  -H "X-API-Key: dev-key-123"

Rate limit exceeded:
HTTP/1.1 429 Too Many Requests
X-RateLimit-Remaining: 0

ğŸ¯ What This Project Demonstrates

This project showcases real-world backend & platform engineering skills:

API Gateway design

Secure defaults

Distributed rate limiting

Failure isolation

Observability (logs + traces)

Production-style error handling

This is not a tutorial toy project â€” it reflects patterns used in real microservice platforms.

ğŸš€ Possible Extensions

Per-API-key tiers (free vs premium)

JWT authentication

Public vs private routes

Metrics dashboards (Prometheus + Grafana)

Kubernetes deployment

ğŸ‘¤ Author: IHEB JLASSI

Built as a learning + portfolio project to deepen understanding of:

Spring Cloud Gateway internals

Distributed systems

DevOps & platform engineering practices

